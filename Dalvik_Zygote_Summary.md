
# 7장 Dalvik 과 Zygote

## 안드로이드 서브시스템이 시작되는 과정 
- 리눅스 커널 **컨테이너 제공**: 하드웨어를 프로그램이 실행할 수 있는 표준 리소스와 도구들로 추상화 해주는 환경 

## Zygote
- 안드로이드 애플리케이션은 자기 프로세스에 대한 통제권이 없다 = 컨테이너가 통제 -> zygote 
- 애플리케이션 < Zygote < 운영체제 (kill -9)
- **Zygote**는 안드로이드에서 모든 애플리케이션의 부모 역할을 한다.

## 인터프리터 
- IL (Intermediate Language) 중간 언어 사용 (ex JAVA)
- 다양한 하드웨어 플랫폼에서 실행가능

## 가상 머신 (Virtual Machine) 
- IL을 실행
- 효율성을 손해 보는 대신, 이식성을 제공
  - 원래는 각각 컴퓨터 타깃 아키텍처별로 여러개의 바이너리를 만드는 대신 중간언어용 1개만 제공하니까

## Dalvik (JVM 대비)
- Android의 초기 가상 머신
- 효율성과 **전력 절약**을 중요한 설계 목표로 함  
  -> 효율성의 의미의 대비 (머신은 100% 사용률을 의미), 이식성 대비
- 스택 기반 JVM과 대비하여 레지스터 기반 구조
- 하드웨어 아키텍처와 더 밀접하게 매치
- 성능 최적화에 초점

## 레지스터 기반 vs 스택 기반 비교

- think) 가상 머신과 물리적 아키텍처 간의 차이점

- [링크](https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/)

    | 특징 | 레지스터 기반 | 스택 기반 |
    | --- | --- | --- |
    | 데이터 저장 | 레지스터 | 스택 |
    | 연산 최적화 | 가능 | 제한적 |
    | 프로그램 크기 | 큼 | 작음 |
    | 명령어 실행 속도 | 빠름 | 비교적 느림 |
    | 주소 지정 방식 | 명시적 | 암시적 |

## Dex
- Java 컴파일러와 Dalvik VM 사이에서 Java 바이트코드를 Dalvik 바이트코드로 변환하는 중간 단계
- 이 변환 과정은 DEX 컴파일러에 의해 수행되며, 생성된 .dex 파일은 크기가 작고 Dalvik에 더 최적화
- .class 파일을 단일 .dex 파일로 변환하여 공간을 절약
- 전체 애플리케이션을 하나의 파일로 만듦

### jar 와 차이

#### 차이점
- **.jar 파일**: 각 클래스마다 반복되는 구조를 가짐.
- **.dex 파일**: 전체 프로그램을 하나의 파일에 담음.
- 객체, 문자열 상수 풀, 코드 정의 블록 등이 파일 내에 단 한 번씩만 나타남.

#### 최적화
- 객체 참조가 정의된 블록 내 오프셋으로 표현되어 파일 크기 감소.
- .jar 파일 대비 중복된 정보가 적어 파일 크기가 작아짐.

#### Dalvik 가상 머신의 한계
- 애플리케이션 실행 시 매번 중간 언어 명령어를 번역해야 함.
- JIT(Just-In-Time) 최적화는 효율적이지만 전력 사용에 있어서 낭비가 될 수 있음.
- Dalvik JIT는 실행 간 최적화 정보를 저장하나, 이는 '실시간' 최적화가 아님.

## ART (Android Runtime)
- DEX를 그대로 사용, 코드 수정 없이 실행 가능 
- 처음부터 한 번만 최적화를 수행하는 시스템 구축.
- 실행할 때마다 최적화하는 Dalvik의 접근법과 대비되는 설계 = AOT(Ahead-of-time)
- DEX 중간 언어로 컴파일된 어떤 애플리케이션을 디바이스에 설치된 특정 시점에 dex2oat라는 툴로 네이티브 코드로 변환 = 이식성 보장 
- 시스템이 시작될 때 Android 프레임워크 전체를 사전 로딩 <-> JIT (Just-In-Time) 최적화 방식과 차별화

### 하는일
- 애플리케이션 컴파일 : 애플리케이션 설치 시점 (dex2oat 실행) 
- 링크 : 독립적으로 컴파일된 바이너리를 로딩하고 하나의 바이너리에서 다른 바이너리의 참조를 처리하는 과정, 한번 링크해두면 매번 필요할 때 링크 안해도 됨 
    - 업데이트 하면서 주소 변경해버리면 문제가 될 수 있지만 시스템 단위로 업뎃
- 실행 시작, 실행 이미지 저장   

-> 미리 컴파일하고 미리 링크된 이미지를 구축

### 하이브리드 ART
- 모든 애플리케이션을 처음부터 컴파일 x, 
- 인터프리터 환경에서 처음에 실행하고 프로파일 정보를 수집 -> "hot"한 메소드를 파악한 뒤, 이를 더 최적화된 네이티브 코드로 컴파일  
=> 이로 인해 시스템 업데이트 후에 모든 애플리케이션을 재컴파일할 필요가 없어짐

## ART 컴파일 방식 변화

1. **AOT (Ahead-Of-Time) 컴파일**
- 애플리케이션 설치 시점에 애플리케이션 코드를 기계어로 컴파일
- 애플리케이션이 실행될 때 컴파일이 필요 없어져 실행 시간이 단축
- Android 7.0 (누가) 이전 버전

2. **JIT (Just-In-Time) 컴파일**
- 애플리케이션이 실행되는 동안 필요에 따라 실시간으로 코드를 컴파일
- Android 7.0부터 ART는 AOT 컴파일과 JIT 컴파일을 조합
- 저장 공간도 절약됨.

3. **프로필 기반 컴파일**
- 사용자가 애플리케이션을 사용하는 동안 자주 실행되는 코드 부분을 식별
- 기기가 유휴 상태에서 충전 중일 때 이러한 부분을 AOT 컴파일
- 애플리케이션의 실행 속도를 추가로 향상, JIT 컴파일에 의해 식별된 코드의 최적화를 진행


### ART가 생성하는 파일
- **`.vdex` 파일**: APK 내의 DEX 코드를 압축 해제한 형태로 저장하며, 검증 속도를 높이기 위한 메타데이터를 포함합니다.
- **`.odex` 파일**: AOT 컴파일된 코드를 포함하며, 애플리케이션의 메서드 실행에 사용됩니다.
- **.art 파일 (선택적)**: 애플리케이션의 시작 속도를 높이기 위해 사용되며, 일부 문자열과 클래스의 ART 내부 표현을 포함할 수 있습니다.
- [Android Compilation Process and Binaries (APK, DEX, OAT, ODEX, VDEX, ART)](https://github.com/connglli/blog-notes/issues/35)